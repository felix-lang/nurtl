# Communicating Sequential Processes
## Architrecture
This is the new real time kernel implementing Communicating Sequential Processes.
With this software a *system* is a collection of *processes* which communicate
using *channels*. Systems can communicate with each other and the environment
by connecting to *devices*.

# Hello World
## The coroutine
Here is our first coroutine:
```
  struct hello_world : coroutine_t {
    size_t size()const { return sizeof(*this); }
    con_t *resume() {
      ::std::cout << "Hello World" << ::std::endl;
      return return_control();
    }
  };
```
The code above is written out fully. It can be simplificed
a bit using some macros:
```
  struct hello_world : coroutine_t {
    CSP_SIZE 
    CSP_RESUME_START
      ::std::cout << "Hello World" << ::std::endl;
      CSP_COSUICIDE
    CSP_RESUME_END
  };
```


# The mainline
```
  int main() {
    alloc_ref_t system_allocator = new malloc_free_allocator_t;
    auto system = new system_t(system_allocator);

    auto process_allocator = system_allocator;

    auto hello = new(process_allocator) hello_world();

    csp_run(system, process_allocator, hello);

    delete system;
  }
```

You can run **csp** anywhere by simply calling the **csp_run** function.
It requires three arguments:

  * A pointer to a system object
  * A reference to a process allocator
  * A pointer to a suspended, ready to run continuation object

The system constructor requires an allocator which is used to allocate store
for system objects. We have to use a reference counting smart pointer of
type **alloc_ref_t** to construct the system. We construct it from a pointer
to a **malloc_free_allocator_t** object.

The continuationm object **hello** is an instance of the **hello_world** class.
It is a suspended coroutine continuation, ready to run, but not activated yet.
The **csp_run** function will activate it.

This object *must* be constructed by the process allocator passed to the **csp_run**
function. To do this, we pass that allocator to the *new* operator as an argument.

After execution is complete, we should delete the system object.
The allocator object and continuation object will be deleted automatically.

# A pipeline
Our system is ideally suited to stream processing. We will construct a simple
pipeline as a demonstration. The components of the pipeline will be connected
by channels. The long winded boilerplate is shown first, and then simplifying
macros. Ultimately this code will be generated by a higher level language translator.

## The consumer
The simplest coroutine is the consumer which reads data from its input
channel and prints it.
```
struct consumer : coroutine_t {
  CSP_SIZE

  // input channel endpoint reference
  chan_epref_t inp;

  // read control block
  iorequest_t rreq;

  // place to put data
  int *data;

  con_t *resume() {
    switch(pc++) {
      case 0:
        // setup the read control block
        rreq.svc_code = read_request_code_e;
        rreq.chan = &inp;
        pdata = (void**)&data;

      case 1:
        // perform the read
        SVC(&rreq)

      case 2:
         // print the value and dispose of the data
        ::std::cout << *data << ::std::end;
        delete_concrete_object(fibre->process_allocator, data);

        // loop back for the next value
        pc = 1;
        return this;
    }
  }
};

The first thing to note is that the system *moves* a pointer to data
from the writer to the reader. Therefore our consumer must delete
the data after using it. This is done using the **delete_concrete_object*
function. This is a template that assumes the size of the data is determined
by the type of the pointer.

It may seem allocating and deallocating data all the time is inefficient.
This is true with the simple *malloc_free_allocator_t* we will be using
for demonstration. However we provide very high performance allocators
which greatly reduce the cost and are suitable for use in real time
multithreaded signal processing applications.

The second thing to note is that the code is **flat** assembler level code.
There are no local variables, we only use non-static data members.
We don't even use a for loop! 

This is because **the machine stack must be empty when a service call is performed**.
In particular, the **SVC** macro returns control to the system scheduler, and
any local variables would be lost. Indeed the location in the code is also lost!

To fix this, we use a special variable **pc** as the program counter.
It is simply the integer value of the next case to be executed when the
routine is **resume()**d




## The producer
The second thing we're going to do is to make a producer coroutine that
spits out the integers 1 to 10.

```
struct producer : coroutine_t {
  CSP_SIZE

  // output channel endpoint reference
  chan_epref_t out;
 
  // service control block for write operation
  iorequest_t wreq;

  // data to be written
  int *data;

  con_t *resume() override {
    switch(pc++) {
      case 0:
        data = new(fibre->process_allocator) 1; // first value to write

        // set up the write control block
        wreq.svc_code = write_request_code_e;
        wreq.chan = &out;
        pdata = &data;

      case 1:
        // check for termination
        if (*data > 10) return return_control();

        // write the data
        SVC(&wreq)

      case 2:
        // increment data
        ++*data;
      
       // loop around again    CSP_SIZE 
    CSP_RESUME_START
      ::std::cout << "Hello World" << ::std::endl;
      CSP_COSUICIDE
    CSP_RESUME_END
  };

       pc = 1;
       return this;
    }
  }
};

```




