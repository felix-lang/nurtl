\documentclass[oneside]{book}
\usepackage{xcolor}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage{parskip}
\usepackage{minted}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usemintedstyle{friendly}
\setminted{bgcolor=bg,xleftmargin=15pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\usepackage{graphicx}
\title{Communicating Sequential Processes\\ in C++}
\author{John Skaller}
\begin{document}
\maketitle
\tableofcontents
\chapter{CSP model}
The CSP kernel supports a simple architecture.

\section{Systems}
A {\em system} consists of several {\em processes} which communicate
using {\em asynchronous channels}. Systems are used to manage 
core {\em internal} resources: processing elements (CPUs), program code,
time, and data memory.

A {\em device} is an arbitrary object and associated service thread which is
used to manage {\em external} resources, including network and file system access,
and user interfaces.


\includegraphics{../src/tex/system.png}

Processes within the same system can communicate with each other or
with devices. Processes in distinct systems must use a device as
a middleman to communicate.

\section{Processes}
The execution of a process is effected by one or more {\em threads}.
If there is only one, the process is {\em single threaded,} otherwise
if there are two or more, {\em multi-threaded.} Every process is started
with a single {\em initial} thread.

A {\em fibre} is a logical thread of control and associated execution
context. Each process consists of a collection of fibres. 

Fibres in a process are {\em running} if a thread is elaborating the
fibre's program code, otherwise the fibre is {\em suspended}. 

A suspended fibre can either be {\em ready} or {\em waiting}.
The collection of ready and running fibres are said to be {\em active}.

All the ready fibres of a processes are maintained in a set and
are owned by their process. Running fibres are owned by the thread
running them which are owned by the thread's process.

When a thread is out of work, it attempts to locate a 
ready fibre the and run it. If there are no ready fibres,
no fibres are running, and there are no fibres waiting on
asynchronous I/O from an external device or another system,
then the process terminates and all associated memory is released,
all but the initial thread are terminated, and the initial thread
returns control.

\includegraphics{../src/tex/process.png}


\section{Fibres}

A {\em fibre} consists of a stack of continuations.

\includegraphics{../src/tex/fibre.png}

\section{Channels}

A {\em channel} is a synchronisation primitive which also allows transmission
of data.\

Channels are accessed via {\em channel endpoints}, using {\em channel endpoint references.}

A particular channel enpoint may be accessed only from the continuations
of one fibre; that is, each endpoint must be uniquely owned by a single
fibre. This invariant ensures the correct termination of fibres
making I/O requests which cannot be satisfied. 

\includegraphics{../src/tex/channel.png}

\chapter{Access}
Objects in the system can access others using either pointers
or reference counting smart pointers. A variable containing a pointer
which expresses ownership is called a {\em strong pointer variable}.
Reference counting pointer variables are always strong.

Ordinary pointers can also be strong. In this case, the object referred
to must be manually deleted before the object containing the variable
is destroyed.

A weak pointer variable is a variable containing a pointer which provides
access to an object which owns, directly or indirectly, the containing
variable. Such objects must be deleted before the owning object is deleted
so that the lifetime of the weak pointer variable is contained temporally
in the owner lifetime.

\includegraphics{../src/tex/weak_access.png}

\chapter{Operational Semantics}
The core semantic operations of the system are construction of
processes, threads, and fibres, and channel I/O.

Reads and writes on channels are performed with special service calls
which are given a channel endpoint reference. The semantic rules
are simple enough.

A channel may be in three states. It may be empty, consist of a set
of readers, or consist of a set of writers.

When a write is performed then, if the channel is empty or consists 
of a set of writers, the fibre performing the write is added to the channel.
Since this fibre we the currently running fibre of some thread, and the
fibre is now suspended, the thread no attempts to find another 
fibre to execute.

If the channel contains a reader then, instead, it is removed from
the channel. Data is transfered from the writer to the reader.
Nominally, both fibres then become active fibres of their 
respective processes.




\end{document}
